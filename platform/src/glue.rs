// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_SqlError {
    OtherErr = 0,
    QueryFailed = 1,
}

impl core::fmt::Debug for discriminant_SqlError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::OtherErr => f.write_str("discriminant_SqlError::OtherErr"),
            Self::QueryFailed => f.write_str("discriminant_SqlError::QueryFailed"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union SqlError {
    _sizer: [u8; 1],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_SqlData {
    Blob = 0,
    Boolean = 1,
    Int = 2,
    Real = 3,
    Text = 4,
}

impl core::fmt::Debug for discriminant_SqlData {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Blob => f.write_str("discriminant_SqlData::Blob"),
            Self::Boolean => f.write_str("discriminant_SqlData::Boolean"),
            Self::Int => f.write_str("discriminant_SqlData::Int"),
            Self::Real => f.write_str("discriminant_SqlData::Real"),
            Self::Text => f.write_str("discriminant_SqlData::Text"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32"
))]
#[repr(C)]
pub union SqlData {
    Blob: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    Boolean: bool,
    Int: i64,
    Real: f64,
    Text: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 24],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union SqlData {
    Blob: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    Boolean: bool,
    Int: i64,
    Real: f64,
    Text: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 32],
}

#[cfg(target_arch = "x86")]
#[repr(C)]
pub union SqlData {
    Blob: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    Boolean: bool,
    Int: i64,
    Real: f64,
    Text: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 16],
}

impl SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_SqlError {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_SqlError>(*bytes.as_ptr().add(0))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_SqlError) {
        let discriminant_ptr: *mut discriminant_SqlError = (self as *mut SqlError).cast();

        unsafe {
            *(discriminant_ptr.add(0)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named OtherErr, which has no payload.
    pub const OtherErr: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<SqlError>()];

        bytes[0] = discriminant_SqlError::OtherErr as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<SqlError>()], SqlError>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the OtherErr tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_OtherErr(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the OtherErr tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_OtherErr(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named QueryFailed, which has no payload.
    pub const QueryFailed: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<SqlError>()];

        bytes[0] = discriminant_SqlError::QueryFailed as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<SqlError>()], SqlError>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the QueryFailed tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_QueryFailed(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the QueryFailed tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_QueryFailed(&self) {
        ()
    }
}

impl Drop for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_SqlError::OtherErr => {}
                discriminant_SqlError::QueryFailed => {}
            }

    }
}

impl Eq for SqlError {}

impl PartialEq for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_SqlError::OtherErr => true,
                discriminant_SqlError::QueryFailed => true,
            }
        }
    }
}

impl PartialOrd for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_SqlError::OtherErr => Some(core::cmp::Ordering::Equal),
                discriminant_SqlError::QueryFailed => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_SqlError::OtherErr => core::cmp::Ordering::Equal,
                discriminant_SqlError::QueryFailed => core::cmp::Ordering::Equal,
            }
        }
    }
}

// impl Copy for SqlError {}

impl Clone for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_SqlError::OtherErr => core::mem::transmute::<
                    core::mem::MaybeUninit<SqlError>,
                    SqlError,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_SqlError::QueryFailed => core::mem::transmute::<
                    core::mem::MaybeUninit<SqlError>,
                    SqlError,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_SqlError::OtherErr => discriminant_SqlError::OtherErr.hash(state),
            discriminant_SqlError::QueryFailed => discriminant_SqlError::QueryFailed.hash(state),
        }
    }
}

impl core::fmt::Debug for SqlError {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("SqlError::")?;

        unsafe {
            match self.discriminant() {
                discriminant_SqlError::OtherErr => f.write_str("OtherErr"),
                discriminant_SqlError::QueryFailed => f.write_str("QueryFailed"),
            }
        }
    }
}

impl SqlData {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_SqlData {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_SqlData>(*bytes.as_ptr().add(16))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_SqlData) {
        let discriminant_ptr: *mut discriminant_SqlData = (self as *mut SqlData).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Blob`, with the appropriate payload
    pub fn Blob(arg: roc_std::RocList<u8>) -> Self {
        let mut answer = Self {
            Blob: core::mem::ManuallyDrop::new(arg)
        };

        answer.set_discriminant(discriminant_SqlData::Blob);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Blob` and convert it to `Blob`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Blob`.
    pub unsafe fn into_Blob(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Blob);

        let payload = core::mem::ManuallyDrop::take(&mut self.Blob);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Blob` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Blob`.
    pub unsafe fn as_Blob(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Blob);

        let payload = &self.Blob;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Boolean`, with the appropriate payload
    pub fn Boolean(arg: bool) -> Self {
        let mut answer = Self {
            Boolean: arg
        };

        answer.set_discriminant(discriminant_SqlData::Boolean);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Boolean` and convert it to `Boolean`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Boolean`.
    pub unsafe fn into_Boolean(self) -> bool {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Boolean);

        let payload = self.Boolean;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Boolean` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Boolean`.
    pub unsafe fn as_Boolean(&self) -> &bool {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Boolean);

        let payload = &self.Boolean;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Int`, with the appropriate payload
    pub fn Int(arg: i64) -> Self {
        let mut answer = Self {
            Int: arg
        };

        answer.set_discriminant(discriminant_SqlData::Int);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Int` and convert it to `Int`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Int`.
    pub unsafe fn into_Int(self) -> i64 {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Int);

        let payload = self.Int;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Int` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Int`.
    pub unsafe fn as_Int(&self) -> &i64 {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Int);

        let payload = &self.Int;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Real`, with the appropriate payload
    pub fn Real(arg: f64) -> Self {
        let mut answer = Self {
            Real: arg
        };

        answer.set_discriminant(discriminant_SqlData::Real);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Real` and convert it to `Real`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Real`.
    pub unsafe fn into_Real(self) -> f64 {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Real);

        let payload = self.Real;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Real` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Real`.
    pub unsafe fn as_Real(&self) -> &f64 {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Real);

        let payload = &self.Real;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Text`, with the appropriate payload
    pub fn Text(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            Text: core::mem::ManuallyDrop::new(arg)
        };

        answer.set_discriminant(discriminant_SqlData::Text);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Text` and convert it to `Text`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Text`.
    pub unsafe fn into_Text(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Text);

        let payload = core::mem::ManuallyDrop::take(&mut self.Text);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `SqlData` has a `.discriminant()` of `Text` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Text`.
    pub unsafe fn as_Text(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_SqlData::Text);

        let payload = &self.Text;

        &payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_SqlData {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_SqlData>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_SqlData) {
        let discriminant_ptr: *mut discriminant_SqlData = (self as *mut SqlData).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(target_arch = "x86")]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_SqlData {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_SqlData>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(target_arch = "x86")]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_SqlData) {
        let discriminant_ptr: *mut discriminant_SqlData = (self as *mut SqlData).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

impl Drop for SqlData {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_SqlData::Blob => unsafe { core::mem::ManuallyDrop::drop(&mut self.Blob) },
                discriminant_SqlData::Boolean => {}
                discriminant_SqlData::Int => {}
                discriminant_SqlData::Real => {}
                discriminant_SqlData::Text => unsafe { core::mem::ManuallyDrop::drop(&mut self.Text) },
            }

    }
}

impl PartialEq for SqlData {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_SqlData::Blob => self.Blob == other.Blob,
                discriminant_SqlData::Boolean => self.Boolean == other.Boolean,
                discriminant_SqlData::Int => self.Int == other.Int,
                discriminant_SqlData::Real => self.Real == other.Real,
                discriminant_SqlData::Text => self.Text == other.Text,
            }
        }
    }
}

impl PartialOrd for SqlData {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_SqlData::Blob => self.Blob.partial_cmp(&other.Blob),
                discriminant_SqlData::Boolean => self.Boolean.partial_cmp(&other.Boolean),
                discriminant_SqlData::Int => self.Int.partial_cmp(&other.Int),
                discriminant_SqlData::Real => self.Real.partial_cmp(&other.Real),
                discriminant_SqlData::Text => self.Text.partial_cmp(&other.Text),
            }
        }
    }
}

// impl Ord for SqlData {
//     #[cfg(any(
//         target_arch = "arm",
//         target_arch = "aarch64",
//         target_arch = "wasm32",
//         target_arch = "x86",
//         target_arch = "x86_64"
//     ))]
//     fn cmp(&self, other: &Self) -> core::cmp::Ordering {
//             match self.discriminant().cmp(&other.discriminant()) {
//                 core::cmp::Ordering::Equal => {}
//                 not_eq => return not_eq,
//             }

//             unsafe {
//             match self.discriminant() {
//                 discriminant_SqlData::Blob => self.Blob.cmp(&other.Blob),
//                 discriminant_SqlData::Boolean => self.Boolean.cmp(&other.Boolean),
//                 discriminant_SqlData::Int => self.Int.cmp(&other.Int),
//                 discriminant_SqlData::Real => self.Real.cmp(&other.Real),
//                 discriminant_SqlData::Text => self.Text.cmp(&other.Text),
//             }
//         }
//     }
// }

impl Clone for SqlData {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_SqlData::Blob => Self {
                    Blob: self.Blob.clone(),
                },
                discriminant_SqlData::Boolean => Self {
                    Boolean: self.Boolean.clone(),
                },
                discriminant_SqlData::Int => Self {
                    Int: self.Int.clone(),
                },
                discriminant_SqlData::Real => Self {
                    Real: self.Real.clone(),
                },
                discriminant_SqlData::Text => Self {
                    Text: self.Text.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

// impl core::hash::Hash for SqlData {
//     #[cfg(any(
//         target_arch = "arm",
//         target_arch = "aarch64",
//         target_arch = "wasm32",
//         target_arch = "x86",
//         target_arch = "x86_64"
//     ))]
//     fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
//             discriminant_SqlData::Blob => unsafe {
//                     discriminant_SqlData::Blob.hash(state);
//                     self.Blob.hash(state);
//                 },
//             discriminant_SqlData::Boolean => unsafe {
//                     discriminant_SqlData::Boolean.hash(state);
//                     self.Boolean.hash(state);
//                 },
//             discriminant_SqlData::Int => unsafe {
//                     discriminant_SqlData::Int.hash(state);
//                     self.Int.hash(state);
//                 },
//             discriminant_SqlData::Real => unsafe {
//                     discriminant_SqlData::Real.hash(state);
//                     self.Real.hash(state);
//                 },
//             discriminant_SqlData::Text => unsafe {
//                     discriminant_SqlData::Text.hash(state);
//                     self.Text.hash(state);
//                 },
//         }
//     }
// }

impl core::fmt::Debug for SqlData {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("SqlData::")?;

        unsafe {
            match self.discriminant() {
                discriminant_SqlData::Blob => f.debug_tuple("Blob")
        .field(&*self.Blob)
        .finish(),
                discriminant_SqlData::Boolean => f.debug_tuple("Boolean")
        .field(&self.Boolean)
        .finish(),
                discriminant_SqlData::Int => f.debug_tuple("Int")
        .field(&self.Int)
        .finish(),
                discriminant_SqlData::Real => f.debug_tuple("Real")
        .field(&self.Real)
        .finish(),
                discriminant_SqlData::Text => f.debug_tuple("Text")
        .field(&*self.Text)
        .finish(),
            }
        }
    }
}
